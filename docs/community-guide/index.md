# Community Guide

## Overview
The ESDSWG Community Guide is a collection of best-practices and resources for running successful open source communities around NASA ACCESS and other NASA open source software projects. While the Open Source Guide covers the ins and outs of setting up the systems that manage the code, documentation, and user input of a software project--this guide is designed to help you take those systems and build a real community around them.
### Core Team
- Authors and Editors
### Values
#### Transparency
Projects should be transparent to the community.
#### Accessibility
Project assets should be accessible to everyone in the community.
#### Inclusivity
Projects should welcome participation by and collaboration with diverse people and organizations.
_Editor's note: These values are based on NASA's [Open Source Science Initiative principles](https://science.nasa.gov/open-science-overview)_
## Community Flywheel (Getting Started)
Imagine your project as a flywheel[^1] that is initially stationary. In order to get the flywheel moving, you need to put in some initial effort to build momentum. This could involve creating content in the form of blog posts and how-to videos, engaging with potential members of the community at conferences, and providing support and resources to help people get involved. As the flywheel begins to move, it becomes easier to maintain its momentum, as the energy generated by the initial effort is preserved and used to keep it moving.

The key to maintaining a successful community is to keep the flywheel moving by constantly engaging with and supporting the members of the community. This could involve regular communication, providing resources and support, and fostering a positive and inclusive atmosphere. By investing time and effort in building and maintaining the community, the flywheel will continue to spin and generate energy, leading to a vibrant and thriving community.

[^1]: [The flywheel and building momentum with your community](https://orbit.love/blog/a-tactical-guide-to-kickstarting-your-community)
### Open Source is a Superpower
One of the key benefits of open source is that it allows anyone to access and contribute to the project. This can make it easier to attract and engage a wider community of users and developers, which can be particularly helpful in the early stages of building a community. Open source also encourages collaboration and sharing, which can foster a sense of community and engagement among members.

Another benefit of open source is that it can provide greater transparency and accountability in the development of a software project. This can help to build trust and credibility with the community, which can be important for maintaining momentum and engagement over time. Additionally, open source can provide access to a wealth of knowledge and expertise from the wider community, which can be valuable for improving the project and addressing challenges.

Overall, the open source model can be well-suited to building and maintaining a community, as it provides the tools and resources for fostering collaboration, transparency, and engagement. By keeping the flywheel metaphor in mind and investing in the growth and support of the community, a project can maintain momentum and continue to thrive.
### Make Everyone Feel Welcome
It's important to create a welcoming and supportive environment where newcomers can learn and grow, and feel comfortable and valued as members of the community. Here are some tips for creating a welcoming environment for newcomers:

- Be friendly and approachable. Greet new contributors and make an effort to get to know them and their interests.
- Be inclusive. Encourage new contributors to participate and offer their ideas, even if they are not experienced or well-known.
- Be patient. Remember that everyone has to start somewhere, and that it can take time for new contributors to learn the ropes and become comfortable with the project and its community.
- Be clear and concise. Make sure that your communication is clear and easy to understand, and avoid using jargon or complex technical language that may be confusing to newcomers.
- Be helpful. Provide resources and support to help new contributors get started, such as links to relevant documentation, tutorials, or examples. Be available to answer questions and provide guidance as needed.
### Be Responsive
It's important that the community feel active to newcomers and that current members see a "pace" and flow to the communication and responsiveness of the project maintainers. Being responsive and engaged with the community while avoiding burning out can sometimes seem overwhelming, but there are steps you can take to manage this responsibility without the stress:

- Set clear boundaries and expectations for your involvement in the community. Establishing regular communication channels where you can provide updates and address concerns from the community.
- Delegate tasks and responsibilities to other members of the community, and to provide support and resources to help them take on these roles.
- Prioritize self-care and avoid overcommitting yourself. Be realistic about the time and energy you have available to devote to the project and community.
- Seek support and advice from others, such as other project maintainers or members of the community, to help you manage your workload and avoid burnout.
### Give More Than You Take
One of the best mechanisms for building and fostering a growing community is to give as much as possible to the group. This giving can come in the form of advice and insight, documentation and how-tos, screencasts, and social events. Consider the value that a member gets from the organization and how that might encourage them to contribute. Only after you've given substantially to the community should you ask your members or contributors to do something. Not only will this make the community feel like they're getting _real_ value from the group (make it worth their time) but it will also inspire genuine and meaningful contributions.
#### Examples of Giving
- Screencast showing the basics of submitting a pull request to the project
- Community leaders writing and publishing documentation and best-practices as guideposts for members
- Responding to questions and issues raised by community members in a timely and helpful manner
- Mentoring new contributors and helping them to become familiar with the project and its goals
- Recognizing and thanking contributors for their contributions, whether big or small
- Hosting events or conferences related to the project, or participating in relevant events and conferences
- Helping to build and maintain partnerships with other organizations or projects that can help to advance the goals of the project
- Actively seeking out and addressing any potential barriers to participation, such as unclear documentation or a lack of resources, and working to make the project more accessible and inclusive.
- Using Twitter and other social media platforms to talk about _how to use_ the software/system/project in your own project
### Handoff/Keeping the Flywheel Spinning
- Communicate openly and transparently with the community. Keep community members informed about any changes or developments related to the project, and solicit their feedback and input.
- Establish clear roles and responsibilities for project leadership and management. This can help to ensure that the project continues to move forward, even if the leadership team changes or expands.
- Prioritize and focus on the most important goals and objectives of the project. This can help to keep the project on track, even as it grows and evolves.
- Encourage and support community participation. Make it easy for community members to contribute, and recognize and thank them for their contributions. This can help to maintain and even grow the community, which is essential for the long-term success of the project.
- Continuously assess and adapt to the changing needs and challenges of the project. Be willing to make changes and adjustments as needed, in order to ensure that the project remains relevant and effective.
## Events and Rituals

### Developer meetings

- **Scope:** Coordination of ongoing development activities
- **Who should attend:** Active contributors to the project, maintainers, project lead
- **Timing:** Depends on project size, ranges from daily to yearly
- **Duration:** Usually 1 hour
- **Advice:** Record progress through issues and pull requests

### Community meetings

- **Scope:** Communication of development activities and events with the broader community, opportunity for community feedback
- **Who should attend:** Typically open to everyone
- **Timing:** Depends on project size, ranges from weekly to quarterly
- **Duration:** Usually 1 hour
- **Advice:**
    - Require registration or have a waiting room
    - Designate a leader for the community meeting
    - Designate a separate note taker
    - Share open notes after the meeting

### Sprints/hackathons

- **Scope:** Synchronous collaboration on open source projects
- **Who should attend:** Defined by sprint organizers, could be focused on a core team, welcoming new contributors, or a combination for larger sprints
- **Timing:** Typically in conjunction with conferences, could be once per year or more frequently for larger projects
- **Duration:** Usually 1-2 days
- **Advice:** 
    - Specify goals for the sprint (e.g., targeted development towards roadmap items from core devs, onboarding new contributors)
    - If onboarding new contributors, label ‘good first issues’ and ‘help wanted’ on GitHub issues
    - If focusing on targeted technical development, communicate to conference leads that expertise is required

### Presentations

- **Scope:** Ranges from general information about the project to in-depth overview of a specific technical aspect
- **Timing:** As frequently as community members have an appetite for presenting
- **Format:** Varies from informal videos, conference presentations, podcasts, or community presentations

### Workshops

- **Scope:** In depth introduction to software tools
- **Timing:** Typically infrequently unless following a model such as Software Carpentry
- **Duration:** Typically 1-5 days
- **Advice:**
    - The people leading the workshops do not need to be the same as the person coordinating the workshop
    - Require applications and registration
    - Solicit feedback from participants

### Tutorials

- **Scope:** Succinct introduction to software
- **Timing:** As frequently as community members have an appetite for leading tutorials
- **Duration:** Typically 1 - 4 hr
- **Advice:** 
    - Clearly communicate expected prior experience and target audience
    - Record videos where possible and share for future reference

### References

- https://opensourceevents.github.io/
- https://mentored-sprints.netlify.app/


## Leadership and Mentoring
## Resolving Conflicts
- [Contributor Covenant](https://www.contributor-covenant.org/version/2/0/code_of_conduct/) is a good place to start
## Metrics

> I fundamentally believe that pragmatic sustainable software is better built organically and collectively. I am curious what metrics might capture these more community-supportive behaviors.

*Mathew Rocklin, DASK*

The measurement of how successful your community is can be extremely difficult to quantify. There are a number of possible indicators but they, individually, may tell only part of the whole story. They are also, generally, open to interpretation.

Given this, it would seem prudent to measure as many of these indicators as possible and interpolate to get a true picture of community vibrancy, growth, engagement, etc.

None of the suggestions below should be used in isolation as a measure. Potential pitfalls of that practice may be itemized for each suggestion below.

### How vibrant is your community?
Blurb neeed here!

#### Evolution
Is your project changing with time or stagnant?
#### Commits
How much change exists within your project?
[DASK example](https://github.com/dask/dask/graphs/commit-activity)
#### Performance
How well is your community responding to challenges?
##### Open vs Closed issues
Are you opening more issues than closing? Ideally, we would like to close more than we open.
##### Mean time to fix issues
How quickly are you resolving issues? We would like to improve on our fix rate.
#### Demographics
How is your community changing over time?
##### Joined / left project over time
We would like to grow our contribution community. We should also be cognizant of rapid increases or decreases in that community.
#### Diversity
Do we have represenation from a broad number of organizations?
If one organization leaves, would that cause significant problems?
##### Percentage authors by organization
Is one organization particularly dominant? Ideally, we would like a spread between organizations to lessen the risk of sudden community shrinkage and encourage a diversity of ideas.
##### Pony and Elephant factors
The pony factor: the minimum number of developers performing 50% of the commits
The elephant factor: the minimum number of organizations whose employees perform 50% of the commits

### How do you tell if your community is growing/working
Blurb neeed here!
#### Size
Is your community growing, stagnant or shrinking?
##### Authors
The more contributors to your project the more your project is growing. However, it is not a sole indicator growth as it is not a primary indicator of usage.

[DASK example](https://github.com/dask/dask/graphs/contributors)
##### Messsages
Much like authors, large amounts of talk about your project is an indicator of the size of your project. Two authors in regular conversation is a stronger indicator of growth than ten authors who haven't communicated for a year.

[DASK example](https://github.com/dask/dask/graphs/contributors)
##### Documentation views
Downloads and clones of your project may suffer from 'bounce' problems. Ie. I downloaded this tool but I didn't use it. Measuring the views of the projects documentation a good metric for how many users are actively engaged in the use of your project.
#### Engagement
Is our project community serving the greater community?
##### Clones/downloads/forks
The more clones and downloads of a project the more value it seems to demonstrate. However, are those clones and downloads actually used? Are they being downloaded as part of an automated provisioning process rather than an explicit use? 

[DASK example](https://github.com/dask/dask/network/members)
##### No. of dependencies
A project being used by other projects is a measure of engagement. In much the same way that citations of a paper by other papers is an indication of value.

[DASK example](https://github.com/dask/dask/network/dependencies)
##### Github stars
A very obvious but nebulous and fickle measure of engagement. Is it of value? On it's own, no. But in conjunction with other metrics it may be useful. 
Metrics: Our download numbers are huge but our github stars are low 
Possible conclusion: This is an essential project to many but it is difficult to use

[DASK example](https://github.com/dask/dask/stargazers)

### Benchmarks

## Tools
## Templates
### Emails
### Pull Requests
### READMEs
## Resources
- [Polite Technology](https://polite.technology/preview)

## Success Stories

### Pangeo

#### What is Pangeo?

[Pangeo](https://pangeo.io) is first and foremost a community of people working collaboratively to develop open source software and infrastructure to enable open science, specifically focused on big data. The community has pioneered the use of large scale interactive cloud computing.  

#### Origin story

In large part, Pangeo grew out of the [Xarray](https://xarray.dev) and [Dask](https://dask.org) projects. Xarray is a Python package for working with multidimensional arrays and datasets and Dask is a Python library for parallel computing. In 2016, a small group of developers and “super users” of these projects convened a [workshop](https://rabernat.github.io/aospy-workshop/) at Columbia University to discuss the idea of a community project for large scale geoscientific data analysis. Out of this meeting came the name and mission of the Pangeo Project. In the months and years since, the Pangeo community has grown to include a large number of scientists, software developers, and infrastructure providers. 

#### Why has Pangeo been successful?

Pangeo’s success can be attributed to five themes:

1. **Clear mission and brand**: Pangeo grew up to solve a specific set of problems. Its mission statement was simultaneously ambitious and inclusive, and its branding (name, logo, design concepts) facilitated its organic growth.  
1. **Community focus**: Pangeo’s approach to community engagement was intentionally open and collaborative. Technical conversations were held in the open on [GitHub](https://github.com/pangeo-data), in regular [community meetings](https://pangeo.io/meeting-notes.html) that were open to anyone. Over time, Pangeo added specific user support channels like [discourse.pangeo.io](https://discourse.pangeo.io/) to crowd source questions and solutions.
1. **Use case driven development**: The Pangeo community was engaged in the project to solve specific challenges within active areas of geoscientific research. Pangeo helped turn pain points in big data workflows into technical problems that open source software projects could help solve. [Here’s](https://github.com/dask/distributed/issues/6360) an example of the kind of interaction this approach fostered, leading to big steps forward for the open source project and motivating research project.
1. **Integrate and improve whenever possible**: Rather than reflexively developing new projects to solve problems, the Pangeo approach was to first attempt to [improve and integrate existing tools](https://medium.com/pangeo/the-pangeo-pattern-9a81ca4bad42). This resulted in the incremental improvements across the scientific Python ecosystem and avoided further fragmentation of the community.
1. **Multifunctional development teams**: The Pangeo community is made up of scientists, software engineers, and data/infrastructure providers. When working on complex problems that span multiple software libraries and pieces of infrastructure, having a multifunctional team engaged on a tough problem is key. [This issue](https://github.com/dask/distributed/issues/6560) on the Distributed issue tracker exemplifies how productive engagements like this can be.
